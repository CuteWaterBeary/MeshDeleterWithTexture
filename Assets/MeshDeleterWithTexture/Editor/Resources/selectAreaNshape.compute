#pragma kernel CSMain

Texture2D<float4> Tex;
int Width;
int Height;

int Pos[2];

RWStructuredBuffer<int2> Points;
RWTexture2D<float4> Result;

[numthreads(4,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	uint2 pos = uint2(Pos[0], Pos[1]);

	float4 targetColor = Tex[pos];

	int dx, dy;
	uint2 endPos;

	uint2 p = pos;

	float4 color = float4(1, 1, 1, 1);

	if (id.x == 0) {
		dx = 0;
		dy = 1;
		endPos = float2(Pos[0], Height);
	}
	else if (id.x == 1) {
		dx = 1;
		dy = 0;
		endPos = float2(Width, Pos[1]);
	}
	else if (id.x == 2) {
		dx = 0;
		dy = -1;
		endPos = float2(Pos[0], 0);
	}
	else if (id.x == 3) {
		dx = -1;
		dy = 0;
		endPos = float2(Pos[0], 0);
	}

	for(int i = 0; i < max(Width, Height); i++)
	{
		uint2 currentPos = uint2(pos.x + dx * i, pos.y + dy * i);

		if (currentPos.x < 0 || currentPos.x >= Width ||
			currentPos.y < 0 || currentPos.y >= Height) break;

		float4 col = Tex[currentPos];

		//Result[currentPos] = float4(1, 0, 0, 1);

		if (col.r == targetColor.r &&
			col.g == targetColor.g &&
			col.b == targetColor.b)
		{
			p = currentPos;
		}
		else
			break;
	}

	Points[id.x] = int2(p.x, p.y);
	Result[p] = color;

	GroupMemoryBarrierWithGroupSync();

	int2 p1Pos = Points[id.x];
	int2 p2Pos = (id.x != 3)? Points[id.x + 1] : Points[0];

	int2 diffp12 = int2(p2Pos.x-p1Pos.x, p2Pos.y-p1Pos.y);
	float distp12 = distance(p1Pos, p2Pos);
	for (int i = 0; i < distp12; i++) 
	{
		Result[p1Pos + diffp12 / distp12 * i] = color;	
	}
}
