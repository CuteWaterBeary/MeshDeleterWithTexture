#pragma kernel CSAddPoint
#pragma kernel CSFill
#pragma kernel CSClear

RWStructuredBuffer<int> Result;
RWTexture2D<float4> SelectAreaTex;

float4 PreviousPoint;
float4 NewPoint;

StructuredBuffer<float4> Points;

int PointCount;

int PenSize;

int Width;

CGPROGRAM
// 太さlineSizeのp1とp2の線分上にpが載っているかどうか
bool isOnLine(float2 p1, float2 p2, float2 p, float lineSize)
{
    float a = (p2.y - p1.y) / (p2.x - p1.x);
    float b = p1.y - a * p1.x;
    return  abs(p.y - (a * p.x + b)) <= lineSize &&
        p.x >= min(p1.x, p2.x) && p.x <= max(p1.x, p2.x) &&
        p.y >= min(p1.y, p2.y) && p.y <= max(p1.y, p2.y);
}

// ABが上向きのベクトルかどうか
bool isUpwardVector(float2 a, float2 b) {
    return b.y - a.y > 0;
}

// ABが下向きのベクトルかどうか
bool isDownwardVector(float2 a, float2 b) {
    return b.y - a.y < 0;
}

// ABとCDが平行なベクトル関係か
bool isParallel(float2 a, float2 b, float2 c, float2 d) {
    float ab = (b.y - a.y) / (b.x - a.x);
    float cd = (d.y - c.y) / (d.x - c.x);
    return ab == cd;
}

// 外積
float mycross(float2 vec1, float2 vec2) {
    return vec1.x * vec2.y - vec1.y * vec2.x;
}

// ABとCDが交わっているか
bool isCrossLine(float2 a, float2 b, float2 c, float2 d) {
    return mycross(b - a, c - a) * mycross(b - a, d - a) <= 0 &&
        mycross(d - c, a - c) * mycross(d - c, b - c) <= 0;
}
ENDCG

[numthreads(1, 1, 1)]
void CSAddPoint(uint2 id : SV_DispatchThreadID)
{
    // 半径PenSize範囲内だったら塗る
    if (distance(id, NewPoint.xy) <= PenSize) {
        SelectAreaTex[id] = float4(1, 1, 1, 1);
        return;
    }

    if (PreviousPoint.x == -1) return;

    // 前回と今回の点を繋いだ線分上だったら塗る
    if (isOnLine(PreviousPoint.xy, NewPoint.xy, id, PenSize)) {
        SelectAreaTex[id] = float4(1, 1, 1, 1);
        Result[id.y * Width + id.x] = true;
    }
}

[numthreads(1, 1, 1)]
void CSFill(int2 id : SV_DispatchThreadID)
{
    int count = 0;

    // すべての線分と何回交差するか調べる
    for (int i = 0; i < PointCount; i++) {
        int j = i + 1;
        if (j >= PointCount) {
            j = 0;
        }

        float2 a = Points[i].xy;
        float2 b = Points[j].xy;
        float2 c = id;
        float2 d = float2(Width + 1, id.y);

        if (!isParallel(a, b, c, d) && // 平行ならカウントしない
            isCrossLine(a, b, c, d) && // 交差するならカウントする
            ((isUpwardVector(a, b) && c.y != a.y) || // 上向きベクトルの始点と重なるならカウントしない
            (isDownwardVector(a, b) && c.y != b.y)) // 下向きベクトルの終点と重なるならカウントしない
        ) {
            count++;
        }
    }

    // 線分との交差回数が奇数なら塗る
    if (fmod(count, 2) == 1) {
        SelectAreaTex[id] = float4(1, 1, 1, 1);
        Result[id.y * Width + id.x] = true;
    }
}

[numthreads(1, 1, 1)]
void CSClear(int2 id : SV_DispatchThreadID)
{
    SelectAreaTex[id] = float4(0, 0, 0, 1);
    Result[id.y * Width + id.x] = false;
}
